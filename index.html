<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDB Viewer with STL Export</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; background: #111; color: #eee; }
    #controls {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0, 0, 0, 0.85);
      padding: 12px;
      border-radius: 8px;
      z-index: 10;
      width: 300px;
    }
    input, button {
      width: 100%;
      margin: 5px 0;
      padding: 5px;
      background: #222;
      color: #fff;
      border: 1px solid #333;
      border-radius: 4px;
    }
    label { font-size: 14px; }
    input[type="range"] { width: 100%; }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="pdbFile" />
    <input type="text" id="pdbUrl" placeholder="Paste PDB file URL here" />
    <button onclick="loadPDBfromURL()">Load from URL</button>
    <button onclick="exportSTL()">Export STL</button><br>
    <label><input type="checkbox" id="showAtoms" checked> Show Atoms</label><br>
    <label><input type="checkbox" id="showBonds" checked> Show Bonds</label><br>
    <label><input type="checkbox" id="showRibbon" checked> Show Ribbon + Structure</label><br>
    <label>Bond Distance: <input type="range" id="bondThreshold" min="1" max="2" step="0.1" value="1.6"></label>
  </div>

  <script>
    let scene, camera, renderer, controls;
    let atomMeshes = [], bondMeshes = [], ribbonMesh = null, helixMeshes = [], sheetMeshes = [];
    let currentAtoms = [], lastHelices = [], lastSheets = [];

    init();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 100;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x111111);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      document.getElementById("pdbFile").addEventListener("change", function (event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function (e) {
          parsePDB(e.target.result);
        };
        reader.readAsText(file);
      });

      document.getElementById("showAtoms").onchange =
      document.getElementById("showBonds").onchange =
      document.getElementById("showRibbon").onchange =
      document.getElementById("bondThreshold").oninput = () => renderStructure(lastHelices, lastSheets);

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function getColorForElement(el) {
      const colors = {
        H: 0xffffff, C: 0xaaaaaa, O: 0xff0000, N: 0x00ccff,
        S: 0xffff00, P: 0xff8000, Cl: 0x00ff00, F: 0x00ffff
      };
      return new THREE.Color(colors[el] || 0xff00ff);
    }

    function getAtomRadius(el) {
      const radii = {
        H: 0.25, C: 0.7, N: 0.65, O: 0.6, S: 1.0, P: 1.1, Cl: 1.0, F: 0.5
      };
      return radii[el] || 0.8;
    }

    function parsePDB(text) {
      scene.clear();
      atomMeshes = []; bondMeshes = []; ribbonMesh = null;
      helixMeshes = []; sheetMeshes = [];
      currentAtoms = []; lastHelices = []; lastSheets = [];

      const lines = text.split('\\n');
      const helices = [], sheets = [];

      for (const line of lines) {
        if (line.startsWith("HELIX")) {
          const start = line.substring(21, 25).trim();
          const end = line.substring(33, 37).trim();
          helices.push({ start, end });
        } else if (line.startsWith("SHEET")) {
          const start = line.substring(22, 26).trim();
          const end = line.substring(33, 37).trim();
          sheets.push({ start, end });
        } else if (line.startsWith("ATOM") || line.startsWith("HETATM")) {
          const x = parseFloat(line.substring(30, 38));
          const y = parseFloat(line.substring(38, 46));
          const z = parseFloat(line.substring(46, 54));
          const element = line.substring(76, 78).trim();
          const name = line.substring(12, 16).trim();
          const resSeq = line.substring(22, 26).trim();
          currentAtoms.push({ x, y, z, element, name, resSeq });
        }
      }

      lastHelices = helices;
      lastSheets = sheets;
      renderStructure(helices, sheets);
    }

    function renderStructure(helices = [], sheets = []) {
      scene.clear();
      atomMeshes = []; bondMeshes = []; ribbonMesh = null;
      helixMeshes = []; sheetMeshes = [];

      const showAtoms = document.getElementById("showAtoms").checked;
      const showBonds = document.getElementById("showBonds").checked;
      const showRibbon = document.getElementById("showRibbon").checked;
      const bondThreshold = parseFloat(document.getElementById("bondThreshold").value);

      if (showAtoms) {
        for (const a of currentAtoms) {
          const color = getColorForElement(a.element);
          const radius = getAtomRadius(a.element);
          const mat = new THREE.MeshPhongMaterial({ color });
          const sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 16), mat);
          sphere.position.set(a.x, a.y, a.z);
          scene.add(sphere);
          atomMeshes.push(sphere);
        }
      }

      if (showBonds) {
        for (let i = 0; i < currentAtoms.length; i++) {
          for (let j = i + 1; j < currentAtoms.length; j++) {
            const a = currentAtoms[i], b = currentAtoms[j];
            const dx = a.x - b.x, dy = a.y - b.y, dz = a.z - b.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (dist < bondThreshold) {
              const mid = new THREE.Vector3((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2);
              const length = mid.distanceTo(new THREE.Vector3(a.x, a.y, a.z)) * 2;
              const bond = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, length, 8),
                new THREE.MeshPhongMaterial({ color: 0x999999 })
              );
              bond.position.copy(mid);
              bond.lookAt(new THREE.Vector3(b.x, b.y, b.z));
              bond.rotateX(Math.PI / 2);
              scene.add(bond);
              bondMeshes.push(bond);
            }
          }
        }
      }

      if (showRibbon) {
        const caAtoms = currentAtoms.filter(a => a.name === 'CA');
        if (caAtoms.length >= 4) {
          const points = caAtoms.map(a => new THREE.Vector3(a.x, a.y, a.z));
          const curve = new THREE.CatmullRomCurve3(points);
          const geometry = new THREE.TubeGeometry(curve, 100, 0.5, 8, false);
          const material = new THREE.MeshPhongMaterial({ color: 0xff66cc, opacity: 0.7, transparent: true });
          ribbonMesh = new THREE.Mesh(geometry, material);
          scene.add(ribbonMesh);
        }

        for (const h of helices) {
          const a1 = currentAtoms.find(a => a.resSeq === h.start && a.name === 'CA');
          const a2 = currentAtoms.find(a => a.resSeq === h.end && a.name === 'CA');
          if (a1 && a2) {
            const start = new THREE.Vector3(a1.x, a1.y, a1.z);
            const end = new THREE.Vector3(a2.x, a2.y, a2.z);
            const length = start.distanceTo(end);
            const cylinder = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4, 0.4, length, 16),
              new THREE.MeshPhongMaterial({ color: 0x00ff00 })
            );
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            cylinder.position.copy(mid);
            cylinder.lookAt(end);
            cylinder.rotateX(Math.PI / 2);
            scene.add(cylinder);
          }
        }

        for (const s of sheets) {
          const a1 = currentAtoms.find(a => a.resSeq === s.start && a.name === 'CA');
          const a2 = currentAtoms.find(a => a.resSeq === s.end && a.name === 'CA');
          if (a1 && a2) {
            const start = new THREE.Vector3(a1.x, a1.y, a1.z);
            const end = new THREE.Vector3(a2.x, a2.y, a2.z);
            const length = start.distanceTo(end);
            const arrow = new THREE.Mesh(
              new THREE.CylinderGeometry(0.3, 0.5, length, 12),
              new THREE.MeshPhongMaterial({ color: 0x00ffff })
            );
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            arrow.position.copy(mid);
            arrow.lookAt(end);
            arrow.rotateX(Math.PI / 2);
            scene.add(arrow);
          }
        }
      }

      addLights();
    }

    function addLights() {
      scene.add(new THREE.AmbientLight(0x404040));
      const directional = new THREE.DirectionalLight(0xffffff, 1);
      directional.position.set(1, 1, 1).normalize();
      scene.add(directional);
    }

    function loadPDBfromURL() {
      const url = document.getElementById("pdbUrl").value;
      fetch(url)
        .then(res => res.text())
        .then(text => parsePDB(text))
        .catch(err => alert("Failed to load PDB: " + err));
    }

    function exportSTL() {
      const exporter = new THREE.STLExporter();
      const stl = exporter.parse(scene);
      const blob = new Blob([stl], { type: 'text/plain' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'protein_model.stl';
      link.click();
    }
  </script>
</body>
</html>
